# 第二次实验报告——动态规划法



## 1.1 实验目的

1. 编程实现经典的动态规划算法，理解动态规划算法设计的基本思想、程序实

   现的相关技巧，加深对动态规划算法设计与分析思想的理解。通过程序的执行时

   间测试结果，与理论上的时间复杂度结论进行对比、分析和验证。

## 1.2 实验原理

1. 动态规划基本思想是：将原问题分解为相似的子问题，在求解的过程中通过子问题的解描述并求出原问题的解。

2. 其重要的算法步骤就是每算出一个子问题的解就将其保存，并利用填表的方式一步步算出最终结果。

3. 动态规划算法在查找有很多重叠子问题的情况的

   最优解时有效。

4. 0-1 背包问题是使用动态规划算法求解：

   - 通过如下填表的方式保存每一步的值：

     | 物品编号 | 总重量         | 总价值 |
     | -------- | -------------- | ------ |
     | 1        | w~1~           | ...    |
     | 2        | w~1~+w~2~      | ...    |
     | 3        | w~1~+w~2~+W~3~ | ...    |
     | ....     | ....           | ..     |
     | n        | W              | V      |

     

   - 故动态规划算法求解0-1背包问题的时间复杂度为 *O*(*nC*)。

## 

## 1.3 实验内容

1. 编程实现以上求解 0-1 背包问题的动态规划算法，并通过手动设置、生成随机数获得实验数据。记录随着输入规模增加算法的执行时间，分析并以图形方式展现增长率；测试、验证、对比算法的时间复杂度。
2. [work_2.1.c](work_2.1.c) 算法实现的C语言版本。



## 1.4 实验输入数据集

1.  *C* 值不变的情形下随着 *n* 增加，*C*=200、400、800、2000 这四种情形，生成 *n* 个随机数作为 *n* 个物品的价值（*n*=10, 20, 40, 100, 200, 400, 800, 2000）对于每个 *C* 值，记录随着 *n* 增加程序的执行时间。

   

## 1.5 实验预期成果与实际结果

1. *C* 值不变的情形下随着 *n* 增加，程序的执行时间如下所示：







## 2.1 实验目的

1. 对于同一问题，编程实现其分治算法和动态规划算法，通过对比分析，理解动态规划算法的适用情形。通过程序的执行时间测试结果，与理论结论进行对比、分析和验证。

   

## 2.2 实验原理

斐波那契数列**分治算法与动态规划算法的对比**

- 分治算法：
  - 递归调用：**f(n) =  f(n-1) + f(n-2) **
- 动态规划算法：
  - 数组存储，遍历从3到 *n* 的数 **f[i]=f[i-1]+f[i-2] **



## 2.3 实验内容

1. 编程实现以上求斐波纳契数的分治算法和动态规划算法。对于每个算法，记录随着斐波纳契数数列大小增加基本操作的执行次数，分析并以图形方式展现增长率；对比这两个算法，随着数列大小增加算法增长率的变化趋势；测试、验证、对比理论结论。
2. [work_2.2.c](work_2.2.c) 算法实现的C语言版本





## 2.4 实验输入数据集

- 分别测试不同 *n* 值（*n*=5, 10, 15, 20, 25, 30）情形下 DAC_f 和 DP_f 算法的加法次数，记录加法次数，两个算法加法次数的对比曲线图。



## 2.5 实验预期成果与实际结果

- 不同 *n* 值（*n*=5, 10, 15, 20, 25, 30）时两个算法加法次数的对比曲线图如下所示：

  <img width="373" alt="work1_1" src="https://user-images.githubusercontent.com/86522948/174437562-06839aa8-dd44-4371-a22d-a82241d3925e.png">

  <img width="420" alt="work1_2" src="https://user-images.githubusercontent.com/86522948/174437572-701bdc0f-4c10-4c9a-bb81-32f12fdd2cd1.png">
