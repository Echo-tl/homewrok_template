# 第一次实验报告——分治算法


## 学号：20201120559


## 1、实验目的

1. 通过排序算法的程序实现和执行时间测试，与理论上的结论进行对比分析，深入理解算法时间复杂度渐进性态和和增长率的概念；理解分治算法设计的基本思想、递归程序实现的基本方法，加深对分治算法设计与分析思想的理解。

## 

## 2、实验原理

1. 分治算法的基本思想是将一个规模为 *n* 的问题分解为 *k* 个规模较小的子问

   题，这些子问题相互独立且与原问题性质相同。分治算法设计的一般步骤包括：

   - 分解，将要解决的问题划分成若干规模较小的同类问题；
   - 求解，当子问题划分得足够小时，用较简单的方法解决；
   - 合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。

2. 冒泡排序：

   - 从首元素开始，每次比较相邻两个元素的大小，若按升序排列，前者比后者大的则交换顺序；

   - 从头至尾，每对相邻元素进行比较，每趟比较结束后，结尾为最大元素；

   - 重复以上步骤；两层*for*循环，比较n趟，每趟比较n次。

   - 故冒泡排序的时间复杂度为 O( *n^2^* )

     

3. 合并排序：

   - 首先将一个无序序列从中间位置分为两个序列；

   - 再将两个序列按照第一步继续划分，直到所有子序列的长度为1为止；

   - 最后再将两个子序列依次合并为有序序列，并最终合并为有序序列。

   - 合并排序的时间复杂度为 O(*nlogn*)，空间复杂度O(*n*)

     

4. 快速排序：

   - 找一个基准值，本实验中，基准点选择第一个元素，分别设置两个指针 i 和 j ，初始时 i 指向第一个元素，j 指向最后一个元素；

   - 遍历整个数组， 将 i 和 j 指向的元素依次与基准值比较，i 左边的元素是小于基准值的，j 右边的元素是大于基准值的；之道遇到不满足的元素值，将两个元素值交换；

   - 重复以上操作，使用递归函数实现。

   - 快速排序的时间复杂度为O(*nlogn*)

     

## 3、实验内容

1. 以冒泡排序、合并排序和快速排序算法为例，以生成的随机数作为实验中使用的测试数据；

2. 随机数生成包含 100 个随机数的测试数据，记录这些数据三个排序算法比较操作的执行次数：

3. 使用随机数生成方法生成不同规模的测试数据（10 个，100 个，1000 个，2000 个，5000 个，10000 个，100000 个，……），分别记录 BubbleSort、MergeSort 和 QuickSort 算法执行中比较操作的执行次数，图表绘制工具生成随着输入数据增加、以上三个算法比较操作次数增加的对比曲线图（折线）。

4. 使用（3）中生成的测试数据（10 个，100 个，1000 个，2000 个，5000个，10000 个，100000 个，……），对于每种规模的测试数据，分别记录以上两个算法执行中各子问题的规模，并用表格方式记录所有情形各子问题的规模值。

5. [work_2.c](work_2.c) 算法实现的C语言版本。

   

## 4、实验输入数据集

1. 手动输入生成随机数个数的参数 *n*，生成的测试数据（10 个，100 个，1000 个，2000 个，5000个，10000 个，10000个，……），



## 5、实验预期成果与实际结果

1. 使用随机数生成100个随机数后，三个排序算法比较操作的执行次数如下：

   - 第一次生成：

     请输入随机数个数：100
     生成的随机数依次为：
     8913 5700 18887 18776 29002 26288 23353 27167 30686 24443 30089 3680 11718 24836 25957 18085 15795 5711 26775 23835 32364 6928 3022 19526 24248 18437 5537 3571 18558 6537 8913 22126 16171 25703 22478 4086 15700 19692 19325 10862 5533 13376 3897 4949 23257 4086 30744 27128 4978 24545 3439 17382 15371 13865 16536 5541 23909 1439 20978 5027 14719 10830 1834 8047 21506 24658 5817 5417 23003 7406 27822 3384 11306 32216 11438 26170 4699 17111 5433 11073 22418 1424 10286 10812 22349 9117 15506 20147 15685 3808 23949 5304 31893 30743 6837 10266 16925 1968 11664 987
     冒泡排序的比较次数为：2857
     合并排序的比较次数：263
     快速排序比较次数为：194

     

   - 第二次生成：

     请输入随机数个数：100
     生成的随机数依次为：
     7760 12601 4290 11338 25205 16409 6001 11919 2031 32023 16764 20899 28247 16687 23675 25354 18995 22439 3123 9930 387 14413 11204 973 13974 14080 20259 20358 29986 19569 30923 31960 13716 23595 22448 12851 10917 7121 8565 2816 3374 32679 23774 2111 23101 20564 12424 29806 14184 19943 2520 16045 29025 1047 12337 4385 18635 13263 6250 9878 332 30186 3199 9064 26340 31547 31622 30115 15741 3536 1509 105 20163 14199 6595 5780 2613 12674 13244 2205 27516 456 6105 18877 6908 26860 5823 28753 31914 1506 13094 5507 8477 21166 15245 22567 19687 24175 11308 1763
     冒泡排序的比较次数为：2623
     合并排序的比较次数：235
     快速排序比较次数为：308

   - 由此可见，两次生成的测试数据中，冒泡排序的比较最多，合并排序和快速排序的比较次数较少，且比较次数比较接近，但是，快速排序对于输入数据有较强的依赖性，两次随机数的产生，比较次数的差异较大，这是由于快速排序不稳定，其选择的基准值为元素第一个，不能保证基准值左右两边的元素个数都是相同的，所以结果会有差异性。

   

2. 